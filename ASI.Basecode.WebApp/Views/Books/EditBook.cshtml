@*
    For more information on enabling MVC for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860
*@
@model ASI.Basecode.Data.Models.Book;
@{
    ViewData["Title"] = "EditBook";
    Layout = "_AdminSidebarLayout";
}

@section styles {
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" /> 
    <link rel="stylesheet" href="~/css/admin/books/addbook.css" asp-append-version="true" />
    <link rel="stylesheet" href="~/css/admin/common.css" asp-append-version="true" />
    <link rel="stylesheet" href="~/css/admin/books/editbook.css" asp-append-version="true" />
}


<div class="add-book-container">
    <div class="header-section">
        <h1>Edit Book</h1>
        <p>Enter details of the book here.</p>
    </div>

    <form id="addBookForm" asp-action="EditBook">
        <input type="hidden" asp-for="BookId" />
        <div>
            <label for="title">Title:</label>
            <input type="text" id="title" name="Title" required asp-for="Title">
        </div>
        <div>
            <label for="subtitle">Subtitle:</label>
            <input type="text" id="subtitle" name="Subtitle" asp-for="Subtitle">
        </div>
        <div>
            <label for="publicationDate">Publication Date:</label>
            <input type="date" id="publicationDate" name="PublicationDate" asp-for="PublicationDate">
        </div>
        <div>
            <label for="publisher">Publisher:</label>
            <input type="text" id="publisher" name="Publisher" asp-for="Publisher">
        </div>
        <div>
            <label for="publicationLocation">Publication Location:</label>
            <input type="text" id="publicationLocation" name="PublicationLocation" asp-for="PublicationLocation">
        </div>
        <div>
            <label for="description">Description:</label>
            <textarea id="description" name="Description" asp-for="Description"></textarea>
        </div>
        <div>
            <label for="numberOfPages">Number of Pages:</label>
            <input type="number" id="numberOfPages" name="NumberOfPages" asp-for="NumberOfPages">
        </div>
        <div>
            <label for="language">Language:</label>
            <input type="text" id="language" name="Language" asp-for="Language">
        </div>
        <div>
            <label for="seriesName">Series Name:</label>
            <input type="text" id="seriesName" name="SeriesName" asp-for="SeriesName">
        </div>
        <div>
            <label for="seriesOrder">Series Order:</label>
            <input type="number" id="seriesOrder" name="SeriesOrder" asp-for="SeriesOrder">
        </div>
        <div>
            <label for="isbn10">ISBN10:</label>
            <input type="text" id="isbnten" name="ISBN10" asp-for="ISBN10">
        </div>
        <div>
            <label for="isbn13">ISBN13:</label>
            <input type="text" id="isbnthitheen" name="ISBN13" asp-for="ISBN13">
        </div>
        <div>
            <label for="edition">Edition:</label>
            <input type="text" id="edition" name="Edition" asp-for="Edition">
        </div>
        <div>
            <label for="seriesDescription">Series Description:</label>
            <textarea id="seriesDescription" name="SeriesDescription" asp-for="SeriesDescription"></textarea>
        </div>
        <div>
            <label for="author">Author (comma-separated):</label>
            <input type="text" id="author" name="Author" asp-for="Author">
        </div>


        <h3>Cover Image Upload</h3>
        <img src="@Model.CoverImage" id="exisitngCoverImage" />
        <div>
            <label for="coverImageFile">Select Cover Image:</label>
            <input type="file" id="coverImageFile" accept="image/*"> <p id="coverUploadStatus" style="color: gray;"></p>
            <input type="hidden" id="coverImageUrl" name="CoverImageUrl" asp-for="CoverImage">
        </div>

        <h3>Book File Upload (e.g., PDF)</h3>
        <a href="@Model.BookFile" target="_blank" id="existngBookFile">Open Book</a>
        <div>
            <label for="bookFile">Select Book File:</label>
            <input type="file" id="bookFile" accept=".pdf,.epub"> <p id="bookFileUploadStatus" style="color: gray;"></p>
            <input type="hidden" id="bookFileUrl" name="BookFileUrl" asp-for="BookFile">
        </div>

        <button type="submit">Edit Book</button>
    </form>
</div>


<script type="module">

    document.getElementById('coverImageFile').addEventListener('change', function () {
        const fileName = this.files[0] ? this.files[0].name : 'Text';
        document.getElementById('coverFileNameDisplay').value = fileName;
    });

    document.getElementById('bookFile').addEventListener('change', function () {
        const fileName = this.files[0] ? this.files[0].name : 'Text';
        document.getElementById('bookFileNameDisplay').value = fileName;
    });


    // Your Firebase configuration
    //Transfer this secretes into AnalyserNode env or file, and include it in gitignore.
    const firebaseConfig = {
        apiKey: "AIzaSyA4CTMSbgGQN_yLn9lEZlswbZ_2A2Xhl0k",
        authDomain: "basabuzz-ca8fe.firebaseapp.com",
        projectId: "basabuzz-ca8fe",
        storageBucket: "basabuzz-ca8fe.firebasestorage.app",
        messagingSenderId: "206533484485",
        appId: "1:206533484485:web:2c71a06a17d5244efe75ac"
    };

    // Initialize Firebase
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-storage.js";

    const app = initializeApp(firebaseConfig);
    const storage = getStorage(app);

    async function deleteFileFromFirebase(fileUrl) {
        if (!fileUrl) {
            console.warn("Attempted to delete null or empty file URL.");
            return;
        }
        try {
            //Get a reference to the file from the download URL
            const fileRef = ref(storage, fileUrl);
            await deleteObject(fileRef);
            console.log(`Successfully deleted file: ${fileUrl}`);
        } catch (error) {
            alert(`Failed to delete file ${fileUrl}:`, error)
            console.error(`Failed to delete file ${fileUrl}:`, error);
        }
    }

    async function deleteCoverUrlFromError(coverUrlCopy, coverUploadStatusCopy) {
        if (coverUrlCopy) {
            await deleteFileFromFirebase(coverUrlCopy);
            coverUploadStatusCopy.textContent = 'Cover image upload rolled back due to backend error.';
        }
        else {
            alert("No cover Url")
        }
    }

    async function deleteBookUrlFromError(bookFileUploadStatusCopy, bookUrlCopy) {
        if (bookUrlCopy) {
            await deleteFileFromFirebase(bookUrlCopy);
            bookFileUploadStatusCopy.textContent = 'Book file upload rolled back due to backend error.';
        }
        else {
            alert("No book Url")
        }
    }

    async function deleteCoverUrl(coverUrlCopy) {
        if (coverUrlCopy) {
            await deleteFileFromFirebase(coverUrlCopy);
        }
        else {
            alert("No cover Url")
        }
    }

    async function deleteBookUrl(bookUrlCopy) {
        if (bookUrlCopy) {
            await deleteFileFromFirebase(bookUrlCopy);
        }
        else {
            alert("No book Url")
        }
    }

    //Firebase Upload Function
    //This function returns the download URL or null on failure/no file
    async function uploadFileToFirebase(file, path, statusElement) {
        if (!file) {
            statusElement.textContent = 'No file selected.';
            return null; //Indicates no file was provided
        }

        //Generate New File Name
        const timestamp = new Date().getTime();
        const randomString = Math.random().toString(36).substring(2, 8);
        const uniqueFileName = `${timestamp}-${randomString}-${file.name}`;

        const storageRef = ref(storage, path + uniqueFileName);
        const uploadTask = uploadBytesResumable(storageRef, file);

        return new Promise((resolve, reject) => {
            uploadTask.on('state_changed',
                (snapshot) => {
                    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                    statusElement.textContent = `Upload is ${progress.toFixed(2)}% done`;
                },
                (error) => {
                    statusElement.textContent = `Upload failed: ${error.message}`;
                    console.error("Upload error:", error);
                    reject(error); //Reject the promise on upload error
                },
                async () => {
                    try {
                        const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                        statusElement.textContent = 'Upload successful!';
                        resolve(downloadURL); //Resolve with the download URL
                    } catch (error) {
                        statusElement.textContent = `Failed to get download URL: ${error.message}`;
                        console.error("Get Download URL error:", error);
                        reject(error); //Reject the promise if getting URL fails
                    }
                }
            );
        });
    }

    //Form Submission Logic
    document.getElementById('addBookForm').addEventListener('submit', async (event) => {
        event.preventDefault(); //Prevent default form submission initially

        const form = event.target;
        const coverImageFile = document.getElementById('coverImageFile').files[0];
        const bookFile = document.getElementById('bookFile').files[0];

        const coverUploadStatus = document.getElementById('coverUploadStatus');
        const bookFileUploadStatus = document.getElementById('bookFileUploadStatus');
        const coverImageUrlInput = document.getElementById('coverImageUrl');
        const bookFileUrlInput = document.getElementById('bookFileUrl');
        const exisitngCoverImage = document.getElementById('exisitngCoverImage');
        const existngBookFile = document.getElementById('existngBookFile');


        //Indicated wether a new cover or book is uploaded
        let isCoverUploaded = false
        let isBookUploaded = false

        //cover and book url added from add book
        //will be used to delete the previous url if a new one is added.
        const coverImageFromAddBook = exisitngCoverImage.src
        const bookFilFromAddBook = existngBookFile.getAttribute('href');

        //holds the current Url uploded
        let coverUrlHold = exisitngCoverImage.src
        let bookUrlHold = existngBookFile.getAttribute('href');

        // Clear previous status messages
        coverUploadStatus.textContent = '';
        bookFileUploadStatus.textContent = '';


        //Upload files to Firebase
        try {
            if (coverImageFile) {
                coverUploadStatus.textContent = 'Uploading cover image...';
                const coverUrl = await uploadFileToFirebase(coverImageFile, 'book_covers/', coverUploadStatus);
                if (!coverUrl) {
                    alert('Cover image upload failed or was cancelled.');
                    return;
                }
                coverImageUrlInput.value = coverUrl;
                coverUrlHold = coverUrl;
                isCoverUploaded = true
            }

            if (bookFile) {
                // Display initial upload status

                bookFileUploadStatus.textContent = 'Uploading book file...';

                const bookUrl = await uploadFileToFirebase(bookFile, 'book_files/', bookFileUploadStatus);

                //If any upload returned null or failed, the Promise.all would have rejected.

                if (!bookUrl) {
                    alert('Book file upload failed or was cancelled.');
                    return;
                }

                //Set hidden field with obtained URL
                bookFileUrlInput.value = bookUrl;   //Set hidden field with obtained URL
                //Set hold variable
                bookUrlHold = bookUrl//Set hold variable
                isBookUploaded = true
            }

        } catch (uploadError) {
            alert('File upload to Firebase failed.');
            console.error('Firebase upload error during form submission:', uploadError);
            return;
        }

        // Proceed with form data submission to backend
        const formData = new FormData(form);

        // Convert FormData to a plain JavaScript object
        const bookData = {};
        for (const [key, value] of formData.entries()) {
            if (key === 'NumberOfPages' || key === 'Likes' || key === 'AverageRating' || key == "SeriesOrder") {
                //Use the unary plus operator (+) to convert to number.
                bookData[key] = +value || 0;
            } else {
                bookData[key] = value;
            }
        }

        //Double-check URLs are populated
        if (!bookData.CoverImageUrl || !bookData.BookFileUrl) {
            alert('Internal error: File URLs not set after Firebase upload. Please try again.');
            return;
        }

        // Handling of Api
        try {
            const response = await fetch('/api/BookApi/edit', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // Add Authorization header if your backend API requires it. Needed if Admin Log In and Sign up will be implemented
                },
                body: JSON.stringify(bookData)
            });

            if (response.ok) {
                const result = await response.json();
                alert(result.Message || "Book edited successfully!");
                form.reset(); // Clear the form fields
                // Reset upload status messages and hidden URLs
                coverUploadStatus.textContent = '';
                bookFileUploadStatus.textContent = '';
                coverImageUrlInput.value = '';
                bookFileUrlInput.value = '';
                if (isCoverUploaded) {
                    await deleteCoverUrl(coverImageFromAddBook);

                }
                if (isBookUploaded) {
                    await deleteBookUrl(bookFilFromAddBook);

                }
                window.location.href = "/Book/ListBook";

            } else {
                const errorData = await response.json();
                // Check for 'errors' property for validation messages from ASP.NET Core
                alert(`Error: ${JSON.stringify(errorData.errors || errorData.Message || "An unknown error occurred on the server.")}`);
                console.error('Backend error details:', errorData);
                if (isCoverUploaded) {
                    await deleteCoverUrlFromError(coverUrlHold, coverUploadStatus);
                }
                if (isBookUploaded) {
                    await deleteBookUrlFromError(bookFileUploadStatus, bookUrlHold);
                }


            }
        } catch (backendError) {
            console.error('Network or unexpected error during backend submission:', backendError);
            alert('An unexpected error occurred while saving book data. Please try again.');
            if (isCoverUploaded) {
                await deleteCoverUrlFromError(coverUrlHold, coverUploadStatus);
            }
            if (isBookUploaded) {
                await deleteBookUrlFromError(bookFileUploadStatus, bookUrlHold);
            }
        }
    });
</script>
